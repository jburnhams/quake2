<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quake 2 TS - E2E Test Harness</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            z-index: 100;
            white-space: pre;
            background: rgba(0,0,0,0.5);
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="debug">Initializing...</div>
    <canvas id="game-canvas"></canvas>

    <script src="/packages/client/dist/browser/index.global.js"></script>

    <script>
        window.clientConnected = false;

        async function start() {
            console.log('Harness script loaded.');

            const debug = document.getElementById('debug');
            debug.innerText = 'Loading client...';
            console.log('Starting harness...');

            try {
                // Parse query params for connection info
                const params = new URLSearchParams(window.location.search);
                const serverUrl = params.get('connect');

                if (!serverUrl) {
                    debug.innerText = 'No server URL provided in ?connect=';
                    console.error('No server URL provided. Search params:', window.location.search);
                    return;
                }

                debug.innerText = `Connecting to ${serverUrl}...`;
                console.log(`Connecting to ${serverUrl}...`);

                if (typeof Quake2Client === 'undefined') {
                    throw new Error('Quake2Client global not found. Bundle might be missing or invalid.');
                }

                // MOCK ENGINE
                const mockRenderer = {
                    width: 1280,
                    height: 720,
                    stats: {},
                    collisionVis: { render: () => {}, clear: () => {} },
                    renderFrame: () => {},
                    begin2D: () => {},
                    end2D: () => {},
                    registerPic: async (name) => ({ width: 16, height: 16, bind: () => {} }),
                    registerTexture: (name) => ({ width: 16, height: 16, bind: () => {} }),
                    drawPic: () => {},
                    drawString: () => {},
                    drawCenterString: () => {},
                    drawfillRect: () => {},
                    setGamma: () => {},
                    setBrightness: () => {},
                    setBloom: () => {},
                    setBloomIntensity: () => {},
                    setUnderwaterWarp: () => {}
                };

                const mockAssets = {
                    getMap: () => null,
                    listFiles: () => [],
                    loadTexture: async () => ({ width: 16, height: 16, rgba: new Uint8Array(16*16*4) }),
                    loadSprite: async () => ({ frames: [] }),
                    loadSound: async () => ({ duration: 0, buffer: null })
                };

                const mockEngine = {
                    renderer: mockRenderer,
                    assets: mockAssets,
                    trace: (start, end) => ({
                        fraction: 1.0,
                        contents: 0,
                        allSolid: false,
                        startSolid: false,
                        endpos: { x: end.x, y: end.y, z: end.z },
                        plane: { normal: { x: 0, y: 0, z: 1 }, dist: 0, type: 0 }
                    })
                };

                const mockHost = {
                    commands: {
                        register: () => {},
                        execute: () => {}
                    },
                    cvars: {
                        get: (name) => {
                            if (name === 'net_qport') {
                                const qport = params.get('qport');
                                if (qport) return { string: qport, number: parseInt(qport, 10), flags: 0 };
                            }
                            if (name === 'rate') return { string: '25000', number: 25000, flags: 0 };
                            if (name === 'cl_maxpackets') return { string: '60', number: 60, flags: 0 };
                            if (name === 'name') return { string: 'Player', number: 0, flags: 0 };
                            if (name === 'skin') return { string: 'male/grunt', number: 0, flags: 0 };
                            if (name === 'fov') return { string: '90', number: 90, flags: 0 };
                            if (name === 'hand') return { string: '0', number: 0, flags: 0 };

                            return { string: '', number: 0, flags: 0 };
                        },
                        register: () => {},
                        list: () => [],
                        setValue: () => {}
                    }
                };

                // Mock InputController to allow test injection
                const mockInputController = {
                    buildCommand: (dt, now) => {
                        const cmd = window.testInput || {
                            angles: {x:0, y:0, z:0},
                            forwardmove: 0,
                            sidemove: 0,
                            upmove: 0,
                            buttons: 0,
                            impulse: 0,
                            msec: 16,
                            time: now
                        };
                        // Ensure time is updated if using override
                        if (window.testInput) {
                            cmd.time = now;
                        }
                        return cmd;
                    },
                    bindInputSource: () => {},
                    setKeyBinding: () => {},
                    getDefaultBindings: () => ({}),
                    set onInputCommand(cb) { this._cb = cb; },
                    get onInputCommand() { return this._cb; }
                };

                // Initialize Client
                console.log('Creating client instance...');
                const client = Quake2Client.createClient({
                    engine: mockEngine,
                    host: mockHost,
                    inputController: mockInputController
                });

                // Monkey-patch isConnected to ensure reliable status reporting in tests
                client.multiplayer.isConnected = function() {
                    return this.state >= 1;
                };

                // Monkey-patch predict to ensure commands are sent if we believe we are connected,
                // bypassing internal state checks that might lag or mismatch in the harness.
                client.predict = function(cmd) {
                    if (window.clientConnected) {
                        client.multiplayer.sendCommand(cmd);
                    }
                    return client.prediction.enqueueCommand(cmd);
                };

                window.clientInstance = client;

                // Create dummy state to prevent render crash
                const dummyState = {
                    origin: { x: 0, y: 0, z: 0 },
                    velocity: { x: 0, y: 0, z: 0 },
                    viewAngles: { x: 0, y: 0, z: 0 },
                    timeMs: 0,
                    pmFlags: 0,
                    waterLevel: 0,
                    health: 100,
                    armor: 0,
                    ammo: 0,
                    stats: new Array(32).fill(0),
                    damageAlpha: 0,
                    damageIndicators: [],
                    blend: [0, 0, 0, 0],
                    pickupIcon: 0,
                    packetEntities: []
                };

                // Initialize
                console.log('Initializing client...');
                client.init({ state: dummyState, timeMs: 0 });

                debug.innerText = `Client initialized. Connecting to ${serverUrl}...`;
                console.log('Client initialized.');

                // Connect
                try {
                    console.log('Initiating connection...');
                    await client.multiplayer.connect(serverUrl);
                    debug.innerText = 'Connected!';
                    console.log('Connected!');
                    window.clientConnected = true;
                } catch (err) {
                     debug.innerText = `Connection failed: ${err.message}`;
                     console.error(`Connection failed: ${err.message}`);
                     throw err;
                }

                // Start Render Loop
                let loadingStuckCounter = 0;
                function loop() {
                    try {
                        const now = performance.now();

                        // Workaround: If client gets stuck in Loading (4) because 'precache'
                        // command was missed or lost, force it to unblock tests.
                        if (client.multiplayer.state === 4) {
                            loadingStuckCounter++;
                            if (loadingStuckCounter > 60) { // ~1 second @ 60fps
                                console.log('Client stuck in Loading, injecting precache...');
                                client.multiplayer.onStuffText('precache');
                                loadingStuckCounter = 0;
                            }
                        } else {
                            loadingStuckCounter = 0;
                        }

                        client.render({
                            nowMs: now,
                            alpha: 1.0,
                            latest: null,
                            previous: null
                        });

                        setTimeout(loop, 16);
                    } catch (loopErr) {
                         console.error('Render loop crashed:', loopErr);
                         debug.innerText = `Crash: ${loopErr.message}`;
                    }
                }
                loop();

            } catch (e) {
                debug.innerText = `Error: ${e.message}\n${e.stack}`;
                console.error(`Harness error: ${e.message}`);
                console.error(e.stack);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', start);
        } else {
            start();
        }
    </script>
</body>
</html>
