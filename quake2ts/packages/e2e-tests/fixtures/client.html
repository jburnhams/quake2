<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Connection Test Client</title>
</head>
<body>
    <h1>Connection Test Client</h1>
    <div id="status">Disconnected</div>
    <div id="logs"></div>
    <button id="disconnectBtn" onclick="doDisconnect()">Disconnect</button>

    <script>
        // Removed ES module import as it fails in this simple setup

        // Since we cannot easily load the real module system without bundling or a complex dev server in this test environment,
        // we will implement a MockMultiplayerConnection that mimics the protocol minimal behavior for testing command flow.

        class MockNetChan {
            constructor(sendFn) {
                this.sendFn = sendFn;
                this.outgoingSequence = 0;
                this.incomingSequence = 0;
                this.incomingReliableSequence = 0;
            }

            process(data) {
                if (data.byteLength < 10) return;

                const view = new DataView(data);
                const seq = view.getUint32(0, true);
                // Ack is at 4, QPort at 8

                const isReliable = (seq & 0x80000000) !== 0;
                const reliableSeqBit = (seq & 0x40000000) !== 0 ? 1 : 0;
                const cleanSeq = seq & ~0xC0000000;

                if (cleanSeq > this.incomingSequence) {
                    this.incomingSequence = cleanSeq;
                }

                if (isReliable) {
                    if (reliableSeqBit === (this.incomingReliableSequence & 1)) {
                        this.incomingReliableSequence++;
                    }
                }
            }

            transmit(data) {
                this.outgoingSequence++;
                // In real implementation, this wraps data with header.
                // For test server, it expects a NetChan packet.
                // Packet Header: Sequence(4) + Ack(4) + QPort(2)

                const buffer = new ArrayBuffer(10 + data.byteLength);
                const view = new DataView(buffer);

                view.setUint32(0, this.outgoingSequence, true);

                // Ack
                let ack = this.incomingSequence;
                if ((this.incomingReliableSequence & 1) !== 0) {
                    // Set bit 31 (reliable ack)
                    // Note: bitwise OR with 0x80000000 in JS treats numbers as signed 32-bit.
                    // 0x80000000 is -2147483648.
                    ack = (ack | 0x80000000) >>> 0; // Use unsigned shift to treat as unsigned
                }
                view.setUint32(4, ack, true);

                view.setUint16(8, 1234, true); // QPort

                new Uint8Array(buffer).set(new Uint8Array(data), 10);
                this.sendFn(buffer);
            }
        }

        class MockConnection {
            constructor(url) {
                this.url = url;
                this.ws = null;
                this.netchan = null;
                this.connected = false;
                // Defer connection slightly to ensure window.connection is set? No, constructor is synchronous.
                setTimeout(() => this.connect(), 0);
            }

            connect() {
                this.ws = new WebSocket(this.url, 'quake2');
                this.ws.binaryType = 'arraybuffer';

                this.netchan = new MockNetChan((data) => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(data);
                    }
                });

                this.ws.onopen = () => {
                    this.connected = true;
                    document.getElementById('status').textContent = 'Connected';
                    console.log('Connected');

                    // Start command loop
                    this.startLoop();
                };

                this.ws.onmessage = (event) => {
                    console.log('Received data: ' + event.data.byteLength + ' bytes');

                    // Process via NetChan to update acks
                    this.netchan.process(event.data);

                    // Minimal heuristic: If we receive a packet > 100 bytes, it's likely containing configstrings/serverdata
                    // A keepalive or empty packet is small (header only ~10 bytes).
                    if (event.data.byteLength > 100) {
                         console.log('Handshake Data Received');
                         document.getElementById('status').textContent = 'Active';
                    }
                };

                this.ws.onclose = () => {
                    this.connected = false;
                    document.getElementById('status').textContent = 'Disconnected';
                };
            }

            disconnect() {
                if (this.ws) this.ws.close();
            }

            isConnected() {
                return this.connected;
            }

            sendCommand(cmd) {
                if (!this.connected) return;

                // Construct a clc_move command packet
                // We need to send a VALID protocol message, or at least one that doesn't crash the server.
                // The server parser expects:
                // byte cmd = reader.readByte();
                // if (cmd === clc_move) { checksum = reader.readByte(); lastFrame = reader.readLong(); ... }
                // clc_move = 3

                // Protocol:
                // clc_move (3) : byte
                // checksum : byte
                // lastFrame : int32 (4 bytes)
                // ... UserCommand struct ...

                const buffer = new ArrayBuffer(64); // Enough for a command
                const view = new DataView(buffer);
                let offset = 0;

                view.setUint8(offset++, 3); // clc_move
                view.setUint8(offset++, 0); // checksum (0 for now, server warns but processes)
                view.setUint32(offset, 0, true); // lastFrame
                offset += 4;

                // UserCommand struct (partial/dummy)
                offset += 32; // Skip 32 bytes of zeros (valid dummy command + padding)

                const packet = new Uint8Array(buffer, 0, offset);
                // Pass the VIEW (Uint8Array), not the buffer, so byteLength is correct.
                this.netchan.transmit(packet);
            }

            startLoop() {
                setInterval(() => {
                    if (this.connected) {
                        // Send a keepalive or move command
                        this.sendCommand({});
                    }
                }, 100); // 10Hz
            }
        }

        // Global export for test inspection
        window.connection = null;
        window.doDisconnect = function() {
            if (window.connection) window.connection.disconnect();
        };

        const params = new URLSearchParams(window.location.search);
        const serverUrl = params.get('connect');

        if (serverUrl) {
            window.connection = new MockConnection(serverUrl);
        }
    </script>
</body>
</html>
