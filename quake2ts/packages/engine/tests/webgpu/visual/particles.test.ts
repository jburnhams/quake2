import { test } from '../../helpers/visual-testing.js';
import { ParticleRenderer } from '../../../src/render/webgpu/pipelines/particleSystem.js';
import { ParticleSystem } from '../../../src/render/particleSystem.js';
import { RandomGenerator, createMat4Identity, mat4Ortho } from '@quake2ts/shared';
import { Texture2D } from '../../../src/render/webgpu/resources.js';

test('pipeline: particles-basic', async ({ renderAndExpectSnapshot }) => {
  await renderAndExpectSnapshot(
    async (device, format, encoder, view) => {
      // Setup
      const renderer = new ParticleRenderer(device, format);
      const rng = new RandomGenerator(12345);
      const system = new ParticleSystem(100, rng);

      // Spawn a few particles
      system.spawn({
        position: { x: -5, y: -5, z: -10 },
        color: [1, 0, 0, 0.5], // Red, Alpha 0.5
        size: 5,
        lifetime: 10,
        blendMode: 'alpha'
      });

      system.spawn({
        position: { x: 5, y: 5, z: -10 },
        color: [0, 1, 0, 0.5], // Green, Alpha 0.5
        size: 5,
        lifetime: 10,
        blendMode: 'additive'
      });

      // Overlapping particles to test blending
      system.spawn({
          position: { x: 0, y: 0, z: -10 },
          color: [0, 0, 1, 0.5], // Blue
          size: 8,
          lifetime: 10,
          blendMode: 'alpha'
      });
      system.spawn({
          position: { x: 2, y: 2, z: -10 },
          color: [1, 1, 0, 0.5], // Yellow
          size: 8,
          lifetime: 10,
          blendMode: 'additive'
      });

      // Update system to process 0 time (just to ensure state is ready)
      system.update(0);

      // Prepare View
      const projection = createMat4Identity();
      mat4Ortho(projection, -10, 10, -10, 10, 0.1, 100);

      const viewRight = { x: 1, y: 0, z: 0 };
      const viewUp = { x: 0, y: 1, z: 0 };

      // We return a callback that uses the RenderPassEncoder
      return (pass) => {
          renderer.render(pass, projection as Float32Array, viewRight, viewUp, system);
      };
    },
    {
      name: 'particles-basic',
      description: 'Basic particle rendering showing alpha-blended and additive particles of different colors (Red, Green, Blue, Yellow) and sizes.'
    }
  );
});

test('pipeline: particles-smoke', async ({ renderAndExpectSnapshot }) => {
  await renderAndExpectSnapshot(
    async (device, format, encoder, view) => {
      const renderer = new ParticleRenderer(device, format);
      const rng = new RandomGenerator(9999);
      const system = new ParticleSystem(100, rng);

      // spawnSteam uses rng, so we should get deterministic output with seeded rng
      // But we need to call it synchronously for the test setup if possible, or wait.
      // Since we are inside the async setup, we can just call it if we import it top-level or use dynamic import await.

      const { spawnSteam } = await import('../../../src/render/particleSystem.js');
      spawnSteam({
           system,
           origin: { x: 0, y: 0, z: -10 }
      });

      system.update(0);

      const projection = createMat4Identity();
      mat4Ortho(projection, -10, 10, -10, 10, 0.1, 100);
      const viewRight = { x: 1, y: 0, z: 0 };
      const viewUp = { x: 0, y: 1, z: 0 };

      return (pass) => {
          renderer.render(pass, projection as Float32Array, viewRight, viewUp, system);
      };
    },
    {
      name: 'particles-smoke',
      description: 'Smoke/Steam particles generated by spawnSteam.'
    }
  );
});

test('pipeline: particles-explosion', async ({ renderAndExpectSnapshot }) => {
    await renderAndExpectSnapshot(
      async (device, format, encoder, view) => {
        const renderer = new ParticleRenderer(device, format);
        const rng = new RandomGenerator(8888);
        const system = new ParticleSystem(200, rng);

        const { spawnExplosion } = await import('../../../src/render/particleSystem.js');
        spawnExplosion({
             system,
             origin: { x: 0, y: 0, z: -20 }
        });

        system.update(0);

        const projection = createMat4Identity();
        mat4Ortho(projection, -20, 20, -20, 20, 0.1, 100);
        const viewRight = { x: 1, y: 0, z: 0 };
        const viewUp = { x: 0, y: 1, z: 0 };

        return (pass) => {
            renderer.render(pass, projection as Float32Array, viewRight, viewUp, system);
        };
      },
      {
        name: 'particles-explosion',
        description: 'Explosion particles generated by spawnExplosion.'
      }
    );
  });

  test('pipeline: particles-blood', async ({ renderAndExpectSnapshot }) => {
    await renderAndExpectSnapshot(
      async (device, format, encoder, view) => {
        const renderer = new ParticleRenderer(device, format);
        const rng = new RandomGenerator(7777);
        const system = new ParticleSystem(100, rng);

        const { spawnBlood } = await import('../../../src/render/particleSystem.js');
        spawnBlood({
             system,
             origin: { x: 0, y: 0, z: -10 },
             direction: { x: 0, y: 1, z: 0 }
        });

        system.update(0);

        const projection = createMat4Identity();
        mat4Ortho(projection, -10, 10, -10, 10, 0.1, 100);
        const viewRight = { x: 1, y: 0, z: 0 };
        const viewUp = { x: 0, y: 1, z: 0 };

        return (pass) => {
            renderer.render(pass, projection as Float32Array, viewRight, viewUp, system);
        };
      },
      {
        name: 'particles-blood',
        description: 'Blood particles generated by spawnBlood.'
      }
    );
  });

  test('pipeline: particles-many-performance', async ({ renderAndExpectSnapshot }) => {
    await renderAndExpectSnapshot(
      async (device, format, encoder, view) => {
        const renderer = new ParticleRenderer(device, format);
        const rng = new RandomGenerator(1111);
        const count = 5000;
        const system = new ParticleSystem(count, rng);

        // Spawn many particles in a grid
        const grid = Math.ceil(Math.sqrt(count));
        for(let i=0; i<count; i++) {
             const x = (i % grid) - grid/2;
             const y = (Math.floor(i / grid)) - grid/2;
             system.spawn({
                position: { x: x * 1.2, y: y * 1.2, z: -50 },
                color: [rng.frandom() * 0.5, rng.frandom() * 0.5, rng.frandom() * 0.5, 0.2],
                size: 2,
                lifetime: 100,
                blendMode: 'additive'
             });
        }

        system.update(0);

        const projection = createMat4Identity();
        mat4Ortho(projection, -50, 50, -50, 50, 0.1, 100);
        const viewRight = { x: 1, y: 0, z: 0 };
        const viewUp = { x: 0, y: 1, z: 0 };

        return (pass) => {
            const start = performance.now();
            renderer.render(pass, projection as Float32Array, viewRight, viewUp, system);
            const end = performance.now();
            // Just logging for now, or could assert on time but that's flaky in CI
            // console.log(`Rendered ${count} particles in ${end - start}ms`);
        };
      },
      {
        name: 'particles-many',
        description: 'Performance test rendering 5000 particles.'
      }
    );
  });

test('pipeline: particles-textured', async ({ renderAndExpectSnapshot }) => {
  await renderAndExpectSnapshot(
    async (device, format, encoder, view) => {
      const renderer = new ParticleRenderer(device, format);
      const rng = new RandomGenerator(67890);
      const system = new ParticleSystem(100, rng);

      // Create a test texture (checkerboard)
      const size = 32;
      const data = new Uint8Array(size * size * 4);
      for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
              const i = (y * size + x) * 4;
              const check = ((Math.floor(x / 4) + Math.floor(y / 4)) % 2) === 0;
              data[i] = check ? 255 : 0;
              data[i + 1] = check ? 255 : 0;
              data[i + 2] = check ? 255 : 0;
              data[i + 3] = 255;
          }
      }

      const texture = new Texture2D(device, {
          width: size,
          height: size,
          format: 'rgba8unorm'
      });
      texture.upload(data);

      // Map of textures
      const textures = new Map<number, Texture2D>();
      textures.set(1, texture); // Index 1

      // Spawn default particles (texture index 0, soft circle)
      system.spawn({
          position: { x: -3, y: 0, z: -10 },
          color: [1, 0, 0, 1],
          size: 6,
          lifetime: 10,
          textureIndex: 0
      });

      // Spawn textured particles (texture index 1, checkerboard)
      system.spawn({
          position: { x: 3, y: 0, z: -10 },
          color: [0, 1, 0, 1], // Green tint
          size: 6,
          lifetime: 10,
          textureIndex: 1
      });

      system.update(0);

      const projection = createMat4Identity();
      mat4Ortho(projection, -10, 10, -10, 10, 0.1, 100);
      const viewRight = { x: 1, y: 0, z: 0 };
      const viewUp = { x: 0, y: 1, z: 0 };

      return (pass) => {
          renderer.render(pass, projection as Float32Array, viewRight, viewUp, system, textures);
      };
    },
    {
      name: 'particles-textured',
      description: 'Particles with custom textures. Left: Default soft circle (Red). Right: Checkerboard texture (Green).'
    }
  );
});
