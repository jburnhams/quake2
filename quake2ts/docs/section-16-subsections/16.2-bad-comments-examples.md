# Section 16.2: Bad Comments & Documentation Issues

**Parent**: Section 16 - Code Quality & Determinism Fixes
**Category**: Documentation & Maintainability
**Priority**: P2 - High (after determinism)
**Estimated Effort**: 1-2 days
**Can Be Done In Parallel**: Yes

## Overview

The codebase contains numerous problematic comments that harm rather than help code understanding. This document catalogs real examples from the codebase and provides fixes.

## Types of Bad Comments

1. **Rambling/Stream-of-Consciousness**: 50+ lines of debugging thought process
2. **Contradictory**: Says one thing, does another
3. **Uncertain**: "maybe", "I think", "probably", "guess"
4. **Unhelpful**: States the obvious or adds no value
5. **Misleading**: Incorrect or outdated information
6. **Missing**: Complex code with zero explanation

---

## 1. Rambling Stream-of-Consciousness Comments

### Example 1: Water Physics Debugging

**File**: `packages/game/src/physics/movement.ts` lines 21-94
**Lines of Comments**: 50+
**Actual Code**: 10 lines

**The Bad Comment**:
```typescript
// In water, entities drift down slowly if dense, or up if buoyant?
// Quake 2 simply runs custom water physics and skips gravity.
// For now, let's assume they sink slowly or are neutrally buoyant.
// SV_Physics_Toss logic in Q2:
// if (ent->waterlevel > 1) G_RunObject (ent); else SV_AddGravity (ent);
// G_RunObject applies water friction and reduced gravity.

// We'll implement simple water drag here for now to prevent infinite acceleration
// and maybe slight gravity.
// Replicating full G_RunObject is complex, but we can do a simple version.

// Apply drag (water friction)
// Based on G_RunObject in g_phys.c
// v[i] = v[i] * 0.8 * ent->waterlevel * frametime; (Wait, this looks like it would kill velocity instantly if > 1)
// Checking original source:
// sv_phys.c SV_Physics_Toss:
// if (ent->waterlevel > 1) G_RunObject (ent);
// g_phys.c G_RunObject:
// 	if (ent->waterlevel > 1)
// 	{
// 		float	*v;
// 		int		i;
// 		v = ent->velocity;
// 		for (i=0 ; i<3 ; i++)
// 			v[i] = v[i] * 0.8 * ent->waterlevel * frametime;
// 	}
// This looks incorrect in C because multiplying by frametime (e.g. 0.1) repeatedly would make it tiny.
// But wait, G_RunObject is called every frame.
// Maybe it meant to subtract? Or maybe 0.8 is 1 - friction * dt?
// Let's assume standard friction logic:
// speed *= 0.8;

// Actually, looking at other sources, it might be:
// v[i] -= v[i] * friction * frametime;
//
// Let's implement a simple viscous drag.
// 0.8 per second? No, 0.8 per frame?

// Let's stick to the existing simple friction but tune it.
// "speed - frametime * speed * 2" means friction = 2.

const speed = Math.sqrt(ent.velocity.x * ent.velocity.x + ent.velocity.y * ent.velocity.y + ent.velocity.z * ent.velocity.z);
if (speed > 1) {
  const newspeed = speed - frametime * speed * 2; // friction 2
  if (newspeed < 0) {
    ent.velocity = { x: 0, y: 0, z: 0 };
  } else {
    const scale = newspeed / speed;
    ent.velocity = scaleVec3(ent.velocity, scale);
  }
}

// Apply reduced gravity in water
// Q2 behavior: objects sink slowly
// In C code (g_phys.c G_RunObject), it calls SV_AddGravity(ent) ONLY if (ent.waterlevel <= 1).
// If waterlevel > 1, it applies friction (above) but DOES NOT call SV_AddGravity.
// However, objects should still sink?
// Quake 2 G_RunObject:
// if (ent->waterlevel > 1) ... friction ...
// if (ent->waterlevel <= 1) SV_AddGravity(ent);

// So in Q2, objects in water DO NOT receive gravity! They just drift with friction.
// Unless they have vertical velocity, they will stop sinking.
// But wait, Gibs sink.
// Maybe they have initial velocity? Or maybe 'gravity' logic is different.
//
// Let's stick to the previous simplified behavior but maybe use a small constant gravity
// to ensure they sink to the bottom if that's desired.
//
// Reverting the aggressive friction change (20 -> 2) to match general expectations unless specific evidence.

// 0.1 * gravity matches previous implementation's attempt to simulate buoyancy/slow sink.
ent.velocity = addVec3(ent.velocity, scaleVec3(gravity, ent.gravity * frametime * 0.1));
```

**Problems**:
- [ ] 50+ lines of stream-of-consciousness debugging
- [ ] Multiple "wait", "maybe", "let's assume" showing uncertainty
- [ ] Pasted C code without clear explanation
- [ ] Multiple abandoned approaches documented
- [ ] No clear conclusion about final approach
- [ ] Rambling makes it hard to understand actual logic

**The Good Comment** (Replace with):
```typescript
/**
 * Apply water friction and modified gravity to entities in water.
 *
 * Quake II water physics (rerelease/g_phys.c G_RunObject):
 * - waterlevel > 1: Apply friction, NO standard gravity
 * - waterlevel <= 1: Normal gravity, no friction
 *
 * DEVIATION: Original C formula appeared to compound incorrectly.
 * This uses simplified viscous drag with empirically tuned constants.
 *
 * @param ent Entity in water
 * @param gravity World gravity vector
 * @param frametime Time delta
 * @see ../rerelease/g_phys.c lines 145-160 G_RunObject
 */
function applyWaterPhysics(ent: Entity, gravity: Vec3, frametime: number): void {
  const WATER_FRICTION = 2.0;      // Drag coefficient (tuned to match original feel)
  const WATER_GRAVITY_SCALE = 0.1; // Reduced gravity for buoyancy effect

  // Apply viscous drag to slow movement
  const speed = vec3Length(ent.velocity);
  if (speed > 1) {
    const newspeed = Math.max(0, speed - frametime * speed * WATER_FRICTION);
    const scale = newspeed / speed;
    ent.velocity = vec3Scale(ent.velocity, scale);
  }

  // Apply reduced gravity (objects slowly sink)
  ent.velocity = vec3Add(ent.velocity,
    vec3Scale(gravity, ent.gravity * frametime * WATER_GRAVITY_SCALE)
  );
}
```

**Fix Tasks**:
- [ ] Replace 50-line ramble with concise 15-line doc comment
- [ ] Extract magic numbers to named constants
- [ ] Document the deviation from original clearly
- [ ] Remove all "maybe", "wait", "I think" language
- [ ] Keep only relevant source reference
- [ ] Add test case verifying water friction behavior

---

## 2. Contradictory Comments

### Example 2: Placeholder Random Function

**File**: `packages/game/src/entities/monsters/parasite.ts` line 41-42

**The Bad Comment**:
```typescript
// Helper to access deterministic RNG or Math.random
const random = () => Math.random();
```

**Problems**:
- [ ] Comment says "deterministic RNG or Math.random" (contradictory)
- [ ] Code only does Math.random (non-deterministic)
- [ ] Comment shows awareness of correct approach but doesn't use it
- [ ] Indicates known technical debt with no action
- [ ] Misleading - suggests something that isn't implemented

**Similar occurrences**:
- [ ] `packages/game/src/entities/monsters/mutant.ts:41`
- [ ] `packages/game/src/entities/monsters/chick.ts:42`
- [ ] `packages/game/src/entities/monsters/flipper.ts:31`
- [ ] `packages/game/src/entities/monsters/brain.ts:33`

**The Fix**:
```typescript
// DELETE the helper entirely
// Use game.random.frandom() directly where needed
// See Section 16.1 for full Math.random() replacement
```

**Fix Tasks**:
- [ ] Remove all `const random = () => Math.random()` helpers
- [ ] Replace calls to `random()` with `game.random.frandom()`
- [ ] Update function signatures to accept `game: GameState`
- [ ] Remove misleading comments

---

## 3. Uncertain "Maybe" and "Guess" Comments

### Example 3: Guessed Monster Stats

**File**: `packages/game/src/entities/monsters/supertank.ts` line 313

**The Bad Comment**:
```typescript
self.viewheight = 64; // Guess, maybe higher?
```

**Problems**:
- [ ] "Guess" indicates unknown value
- [ ] "maybe higher?" shows uncertainty
- [ ] Should look up actual value from original
- [ ] Leaves doubt for future developers
- [ ] May cause bugs if guess is wrong

**The Fix**:
```typescript
self.viewheight = 128; // Per rerelease/m_supertank.cpp:245
```

**Fix Tasks**:
- [ ] Search `../rerelease/m_supertank.cpp` for actual viewheight value
- [ ] Look for `self->viewheight = ` or `ent->viewheight = `
- [ ] Replace guessed value with correct one
- [ ] Add source reference
- [ ] Remove all "guess", "maybe", "probably" language

**Similar Issues to Fix**:
- [ ] Find all comments containing "guess"
  ```bash
  grep -rn "guess\|maybe.*?\|probably\|I think" packages/ | grep "//"
  ```
- [ ] For each: look up correct value in original source
- [ ] Replace guess with verified value

---

## 4. Unhelpful Obvious Comments

### Example 4: Stating the Obvious

**File**: Various

**Bad Examples**:
```typescript
// Increment i
i++;

// Set x to 5
x = 5;

// Check if health is greater than 0
if (health > 0) {

// Loop through all entities
for (const entity of entities) {

// Return true
return true;
```

**Problems**:
- [ ] Comments just restate what code obviously does
- [ ] Add noise without value
- [ ] Can become outdated if code changes
- [ ] Waste time to read

**The Fix**:
```typescript
// DELETE obvious comments
i++;
x = 5;
if (health > 0) {
for (const entity of entities) {
return true;

// OR if context is needed, explain WHY not WHAT:
i++; // Move to next frame in animation sequence
x = 5; // Default weapon slot
if (health > 0) { // Skip processing for dead entities
```

**Fix Tasks**:
- [ ] Identify obvious comments (restate what code does)
- [ ] Delete or replace with WHY comment
- [ ] Keep comments that explain non-obvious business logic

---

## 5. "Wait, Why?" Comments in Tests

### Example 5: Confused Test Comments

**File**: `packages/shared/tests/bsp/trace.debug.test.ts` lines 100, 116, 133, 134

**The Bad Comments**:
```typescript
// Wait, why did it fail with 0?
expect(result).toBe(0);

// Maybe `traceBox` isn't using the updated `collision.ts`?

// Why is it 0?
expect(leafsReached).toBe(0);

// Maybe `headnode` is somehow -1?
```

**Problems**:
- [ ] Comments show confusion about why test works/fails
- [ ] Multiple "maybe" guesses about issues
- [ ] Suggests tests were written before understanding code
- [ ] Makes future developers doubt test validity
- [ ] Should investigate and document actual reason

**The Fix**:
Either:
1. **Investigate and explain**:
```typescript
// Result is 0 because trace starts inside solid brush (startsolid=true)
// Per rerelease/qcommon/cm_trace.c CM_BoxTrace line 245
expect(result).toBe(0);
```

2. **Or delete confused test**:
```typescript
// If you don't understand why test passes/fails, don't commit it
// Remove test and revisit when you understand the system
```

**Fix Tasks**:
- [ ] Find all "wait", "why", "maybe" in test files
- [ ] For each: investigate actual behavior
- [ ] Replace confused comment with explanation
- [ ] Or delete test if it's not understood

---

## 6. Complex Code Without Comments

### Example 6: Plane/Box Intersection Algorithm

**File**: `packages/shared/src/bsp/collision.ts` lines 300-348

**The Bad Code** (no comments):
```typescript
for (const side of brush.sides) {
  const plane = side.plane;
  let dist = plane.dist;

  if (mins && maxs) {
    const ofsX = plane.normal.x < 0 ? maxs.x : mins.x;
    const ofsY = plane.normal.y < 0 ? maxs.y : mins.y;
    const ofsZ = plane.normal.z < 0 ? maxs.z : mins.z;
    dist -= plane.normal.x * ofsX + plane.normal.y * ofsY + plane.normal.z * ofsZ;
  }

  const d1 = start.x * plane.normal.x + start.y * plane.normal.y + start.z * plane.normal.z - dist;
  const d2 = end.x * plane.normal.x + end.y * plane.normal.y + end.z * plane.normal.z - dist;

  if (d2 > 0) getout = true;
  if (d1 > 0) startout = true;

  if (d1 > 0 && d2 >= d1) {
    return;
  }

  if (d1 <= 0 && d2 <= 0) {
    continue;
  }

  if (d1 > d2) {
    const f = (d1 - DIST_EPSILON) / (d1 - d2);
    if (f > enterfrac) {
      enterfrac = f;
      clipplane = plane;
      leadside = side;
    }
  } else {
    const f = (d1 + DIST_EPSILON) / (d1 - d2);
    if (f < leavefrac) leavefrac = f;
  }
}
```

**Problems**:
- [ ] Complex algorithm with zero explanation
- [ ] Variables d1, d2, enterfrac, leavefrac not explained
- [ ] Offset calculation looks arbitrary
- [ ] DIST_EPSILON usage not explained
- [ ] Purpose of getout/startout unclear
- [ ] No reference to algorithm name or source

**The Good Code** (with comments):
```typescript
/**
 * Clip trace line against brush using Liang-Barsky line clipping algorithm.
 *
 * For each plane in brush, calculate where line enters/exits the halfspace.
 * Track the furthest entry point and nearest exit point.
 * If entry > exit, line doesn't intersect brush.
 *
 * For box traces (mins/maxs != null), expand planes by box extents.
 *
 * @see ../rerelease/qcommon/cm_trace.c CM_ClipBoxToBrush lines 145-220
 * @see https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm
 */
for (const side of brush.sides) {
  const plane = side.plane;
  let dist = plane.dist; // Distance from origin to plane

  // For box traces, adjust plane distance by box corner furthest along normal
  if (mins && maxs) {
    // Choose max or min extent based on plane normal direction
    // This effectively expands the plane outward by the box extents
    const ofsX = plane.normal.x < 0 ? maxs.x : mins.x;
    const ofsY = plane.normal.y < 0 ? maxs.y : mins.y;
    const ofsZ = plane.normal.z < 0 ? maxs.z : mins.z;
    dist -= plane.normal.x * ofsX + plane.normal.y * ofsY + plane.normal.z * ofsZ;
  }

  // Calculate signed distance of start/end points from plane
  // d > 0: point is in front of plane (outside halfspace)
  // d < 0: point is behind plane (inside halfspace)
  // d = 0: point is on plane
  const d1 = start.x * plane.normal.x + start.y * plane.normal.y + start.z * plane.normal.z - dist;
  const d2 = end.x * plane.normal.x + end.y * plane.normal.y + end.z * plane.normal.z - dist;

  // Track if line ever exits or starts outside brush
  if (d2 > 0) getout = true;   // End point is outside
  if (d1 > 0) startout = true; // Start point is outside

  // Early exit: if moving away from plane, can't enter brush
  if (d1 > 0 && d2 >= d1) {
    return; // Moving parallel or away from plane
  }

  // Skip if both points behind plane (inside this halfspace)
  if (d1 <= 0 && d2 <= 0) {
    continue;
  }

  // Calculate intersection fraction (0 = start, 1 = end)
  // Use epsilon for numerical stability
  if (d1 > d2) {
    // Entering the halfspace (crossing from front to back)
    const f = (d1 - DIST_EPSILON) / (d1 - d2);
    if (f > enterfrac) {
      enterfrac = f;        // Track furthest entry point
      clipplane = plane;    // Remember which plane we entered through
      leadside = side;      // Remember surface flags for this plane
    }
  } else {
    // Exiting the halfspace (crossing from back to front)
    const f = (d1 + DIST_EPSILON) / (d1 - d2);
    if (f < leavefrac) {
      leavefrac = f; // Track nearest exit point
    }
  }
}

// After checking all planes:
// - If enterfrac > leavefrac: line doesn't intersect brush
// - Otherwise: line intersects brush between enterfrac and leavefrac
```

**Fix Tasks**:
- [ ] Add algorithm overview comment at function level
- [ ] Add inline comments explaining each section
- [ ] Explain what d1, d2 represent
- [ ] Explain enterfrac/leavefrac purpose
- [ ] Document epsilon usage
- [ ] Add reference to original source
- [ ] Consider extracting to well-named functions

---

## Summary of Issues Found

### Rambling Comments (1-2 days to fix)
- [ ] `packages/game/src/physics/movement.ts:21-94` (50+ lines)
- [ ] `packages/game/src/entities/spawn.ts:151-153` (uncertain parsing logic)
- [ ] `packages/engine/src/demo/parser.ts:632,641,647` (multiple "maybe"/"probably")

### Contradictory Comments (0.5 days)
- [ ] `parasite.ts:41-42` - Says "deterministic or Math.random", only does Math.random
- [ ] 4 other similar monster files

### Uncertain Comments (1 day)
- [ ] `supertank.ts:313` - "Guess, maybe higher?"
- [ ] All comments with "maybe", "probably", "I think", "guess"
- [ ] Search and fix:
  ```bash
  grep -rn "\(guess\|maybe.*?\|probably\|I think\|not sure\)" packages/ --include="*.ts" | grep "//"
  ```

### Test Confusion Comments (0.5 days)
- [ ] `trace.debug.test.ts` - Multiple "wait, why?" comments
- [ ] `scenario_base1.test.ts:368` - "Wait, if map loading failed..."
- [ ] All test files with uncertain comments

### Missing Comments on Complex Code (2 days)
- [ ] `collision.ts:300-348` - Liang-Barsky algorithm
- [ ] BSP traversal algorithms
- [ ] Entity spawn parsing
- [ ] Network message parsing
- [ ] Any algorithm >20 lines with no comment

## Fix Priority

### P0: Fix Active Harm
- [ ] Contradictory comments (confuse developers)
- [ ] Misleading/incorrect comments

### P1: Remove Uncertainty
- [ ] All "guess", "maybe", "probably" comments
- [ ] Test confusion comments
- [ ] Look up correct values

### P2: Improve Complex Code
- [ ] Add comments to algorithms
- [ ] Explain non-obvious logic
- [ ] Add source references

### P3: Clean Up Noise
- [ ] Remove obvious comments
- [ ] Trim rambling comments
- [ ] Remove redundant explanations

## Success Criteria
- [ ] Zero "guess", "maybe", "probably" in comments
- [ ] Zero contradictory comments
- [ ] All complex algorithms (>20 lines) have explanatory comments
- [ ] All ported code has source reference
- [ ] Test comments explain expected behavior, not confusion
- [ ] Code review: comments are helpful, not harmful

**Estimated Total Time**: 4-6 days to fix all comment issues
